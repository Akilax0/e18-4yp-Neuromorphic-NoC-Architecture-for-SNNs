$date
	Mon Mar 18 20:13:41 2024
$end
$version
	Icarus Verilog
$end
$timescale
	100ps
$end
$scope module testbench $end
$var wire 1 ! spiked $end
$var wire 32 " potential_to_mem [31:0] $end
$var reg 1 # CLK $end
$var reg 32 $ current_potential [31:0] $end
$var reg 3 % decay_rate [2:0] $end
$var reg 4 & spike_in [3:0] $end
$var reg 32 ' v_threshold [31:0] $end
$var reg 128 ( weight [127:0] $end
$scope module a1 $end
$var wire 1 # CLK $end
$var wire 32 ) current_potential [31:0] $end
$var wire 3 * decay_rate [2:0] $end
$var wire 4 + spike_in [3:0] $end
$var wire 32 , v_threshold [31:0] $end
$var wire 128 - weight [127:0] $end
$var wire 1 . spike_adder $end
$var wire 32 / potential_to_mem [31:0] $end
$var wire 32 0 mac_out [31:0] $end
$var wire 32 1 decayed_potential [31:0] $end
$var wire 32 2 adder_out [31:0] $end
$var reg 1 ! spiked $end
$scope module a1 $end
$var wire 32 3 v_threshold [31:0] $end
$var wire 1 . spike $end
$var wire 32 4 potential [31:0] $end
$var wire 32 5 input_weight [31:0] $end
$var wire 32 6 decayed_potential [31:0] $end
$upscope $end
$scope module m1 $end
$var wire 1 # CLK $end
$var wire 4 7 spike_in [3:0] $end
$var wire 128 8 weight [127:0] $end
$var reg 128 9 mask [127:0] $end
$var reg 128 : mult_ans [127:0] $end
$var reg 32 ; mult_output [31:0] $end
$upscope $end
$scope module p1 $end
$var wire 1 # CLK $end
$var wire 3 < decay_rate [2:0] $end
$var wire 32 = membrane_potential [31:0] $end
$var wire 32 > result_divide_by_2_plus_4 [31:0] $end
$var wire 1 ? Exception $end
$var reg 8 @ adjusted_exponent [7:0] $end
$var reg 8 A exponent [7:0] $end
$var reg 8 B exponent_divided_by_2 [7:0] $end
$var reg 8 C exponent_divided_by_4 [7:0] $end
$var reg 23 D mantissa [22:0] $end
$var reg 32 E number_divided_by_2 [31:0] $end
$var reg 32 F number_divided_by_4 [31:0] $end
$var reg 32 G output_potential_decay [31:0] $end
$var reg 2 H sign [1:0] $end
$scope module Addition_Subtraction_1 $end
$var wire 1 I AddBar_Sub $end
$var wire 1 ? Exception $end
$var wire 32 J a_operand [31:0] $end
$var wire 32 K b_operand [31:0] $end
$var wire 1 L operation_sub_addBar $end
$var wire 1 M output_sign $end
$var wire 25 N subtraction_diff [24:0] $end
$var wire 31 O sub_diff [30:0] $end
$var wire 24 P significand_sub_complement [23:0] $end
$var wire 25 Q significand_sub [24:0] $end
$var wire 24 R significand_b_add_sub [23:0] $end
$var wire 24 S significand_b [23:0] $end
$var wire 25 T significand_add [24:0] $end
$var wire 24 U significand_a [23:0] $end
$var wire 32 V result [31:0] $end
$var wire 1 W perform $end
$var wire 32 X operand_b [31:0] $end
$var wire 32 Y operand_a [31:0] $end
$var wire 8 Z exponent_sub [7:0] $end
$var wire 8 [ exponent_diff [7:0] $end
$var wire 8 \ exponent_b_add_sub [7:0] $end
$var wire 31 ] add_sum [30:0] $end
$var wire 1 ^ Comp_enable $end
$scope module pe $end
$var wire 8 _ Exponent_a [7:0] $end
$var wire 25 ` significand [24:0] $end
$var wire 8 a Exponent_sub [7:0] $end
$var reg 25 b Significand [24:0] $end
$var reg 5 c shift [4:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module r1 $end
$var wire 32 d adder_potential [31:0] $end
$var wire 1 . spiked $end
$var wire 32 e v_threshold [31:0] $end
$var wire 32 f reset_value [31:0] $end
$var wire 1 g Exception $end
$var reg 32 h potential_to_mem [31:0] $end
$scope module Addition_Subtraction_1 $end
$var wire 1 i AddBar_Sub $end
$var wire 1 g Exception $end
$var wire 32 j a_operand [31:0] $end
$var wire 32 k b_operand [31:0] $end
$var wire 1 l operation_sub_addBar $end
$var wire 1 m output_sign $end
$var wire 25 n subtraction_diff [24:0] $end
$var wire 31 o sub_diff [30:0] $end
$var wire 24 p significand_sub_complement [23:0] $end
$var wire 25 q significand_sub [24:0] $end
$var wire 24 r significand_b_add_sub [23:0] $end
$var wire 24 s significand_b [23:0] $end
$var wire 25 t significand_add [24:0] $end
$var wire 24 u significand_a [23:0] $end
$var wire 32 v result [31:0] $end
$var wire 1 w perform $end
$var wire 32 x operand_b [31:0] $end
$var wire 32 y operand_a [31:0] $end
$var wire 8 z exponent_sub [7:0] $end
$var wire 8 { exponent_diff [7:0] $end
$var wire 8 | exponent_b_add_sub [7:0] $end
$var wire 31 } add_sum [30:0] $end
$var wire 1 ~ Comp_enable $end
$scope module pe $end
$var wire 8 !" Exponent_a [7:0] $end
$var wire 25 "" significand [24:0] $end
$var wire 8 #" Exponent_sub [7:0] $end
$var reg 25 $" Significand [24:0] $end
$var reg 5 %" shift [4:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx %"
bx $"
bx #"
bx ""
bx !"
x~
bx }
bx |
bx {
bx z
bx y
bx x
xw
bx v
bx u
bx t
bx s
bx r
bx q
bx p
bx o
bx n
xm
xl
bx k
bx j
1i
bx h
xg
bx f
bx e
bx d
bx c
bx b
bx a
bx `
bx _
x^
bx ]
bx \
bx [
bx Z
bx Y
bx X
xW
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
xM
xL
bx K
bx J
0I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
x?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
x.
bx -
bx ,
bx +
bx *
bx )
bx (
bx '
bx &
bx %
bx $
0#
bx "
x!
$end
#30
b100 %
b100 *
b100 <
b10100 $
b10100 )
b10100 =
b1001110 '
b1001110 ,
b1001110 3
b1001110 e
b1001110 k
b1000000 (
b1000000 -
b1000000 8
b0 &
b0 +
b0 7
#40
b0 0
b0 5
b0 ;
b1111111111111111111111111101100 O
b11111111 Z
b11111111 a
b0 c
b1011111111111111111101100 N
b1011111111111111111101100 b
b1111111110000000000000000011110 ]
b100000000000000000010100 Q
b100000000000000000010100 `
b0 P
b110000000000000000011110 T
1?
b0 >
b0 V
1L
b10000000000000000001010 R
1W
b11111111 \
b1 [
b100000000000000000010100 S
b100000000000000000010100 U
0^
0M
b11111111 _
b1111111000000000000000000010100 X
b1111111100000000000000000010100 Y
b1111111000000000000000000010100 F
b1111111000000000000000000010100 K
b1111111100000000000000000010100 E
b1111111100000000000000000010100 J
b11111110 C
b11111111 B
b10100 D
b0 A
b0 H
1#
#80
0#
#110
