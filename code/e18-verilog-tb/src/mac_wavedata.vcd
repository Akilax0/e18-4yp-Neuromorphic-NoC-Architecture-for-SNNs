$date
	Mon Apr  8 13:35:53 2024
$end
$version
	Icarus Verilog
$end
$timescale
	100ps
$end
$scope module testbench $end
$var wire 32 ! result [31:0] $end
$var reg 1 " CLK $end
$var reg 1 # CLK_count $end
$var reg 1 $ clear $end
$var reg 12 % neuron_address [11:0] $end
$var reg 12 & source_address [11:0] $end
$var reg 60 ' source_addresses_array [59:0] $end
$var reg 160 ( weights_array [159:0] $end
$scope module m1 $end
$var wire 1 " CLK $end
$var wire 1 $ clear $end
$var wire 12 ) neuron_address [11:0] $end
$var wire 12 * source_address [11:0] $end
$var wire 60 + source_addresses_array [59:0] $end
$var wire 160 , weights_array [159:0] $end
$var wire 1 - excpetion $end
$var wire 32 . added_weight [31:0] $end
$var reg 32 / accumulated_weight [31:0] $end
$var reg 1 0 break $end
$var reg 32 1 considered_weight [31:0] $end
$var reg 1 2 i $end
$var reg 1 3 index $end
$var reg 32 4 mult_output [31:0] $end
$scope module add1 $end
$var wire 1 5 AddBar_Sub $end
$var wire 1 - Exception $end
$var wire 32 6 a_operand [31:0] $end
$var wire 32 7 b_operand [31:0] $end
$var wire 1 8 operation_sub_addBar $end
$var wire 1 9 output_sign $end
$var wire 25 : subtraction_diff [24:0] $end
$var wire 31 ; sub_diff [30:0] $end
$var wire 24 < significand_sub_complement [23:0] $end
$var wire 25 = significand_sub [24:0] $end
$var wire 24 > significand_b_add_sub [23:0] $end
$var wire 24 ? significand_b [23:0] $end
$var wire 25 @ significand_add [24:0] $end
$var wire 24 A significand_a [23:0] $end
$var wire 32 B result [31:0] $end
$var wire 1 C perform $end
$var wire 32 D operand_b [31:0] $end
$var wire 32 E operand_a [31:0] $end
$var wire 8 F exponent_sub [7:0] $end
$var wire 8 G exponent_diff [7:0] $end
$var wire 8 H exponent_b_add_sub [7:0] $end
$var wire 31 I add_sum [30:0] $end
$var wire 1 J Comp_enable $end
$scope module pe $end
$var wire 8 K Exponent_a [7:0] $end
$var wire 25 L significand [24:0] $end
$var wire 8 M Exponent_sub [7:0] $end
$var reg 25 N Significand [24:0] $end
$var reg 5 O shift [4:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx O
bx N
bx M
bx L
bx K
xJ
bx I
bx H
bx G
bx F
bx E
bx D
xC
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
x9
x8
bx 7
bx 6
05
bx 4
x3
x2
bx 1
x0
bx /
bx .
x-
b100001010010000101100110011001101000001100101110101110000101001010000100100011100001010001111010000000000000000000000000000000001000010101011100011100001010010 ,
b11000000000100000000000101000000000111000000000110 +
bx *
b1000 )
b100001010010000101100110011001101000001100101110101110000101001010000100100011100001010001111010000000000000000000000000000000001000010101011100011100001010010 (
b11000000000100000000000101000000000111000000000110 '
bx &
b1000 %
x$
0#
0"
bx !
$end
